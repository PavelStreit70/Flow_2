---
title: "Flow_cytometry_xenografts_results"
author: "Streit P"
date: "`r Sys.Date()`"
output: 

  html_document:
    toc: true
    toc_float: true
    theme: flatly
---

pkgbuild::has_rtools()

devtools::install_github("biosurf/cyCombine") 

install.packages('sva')

# To ensure Rstudio looks up BioConductor packages run:
setRepositories(ind = c(1:6, 8))
# Then install package with
devtools::install_github("biosurf/cyCombine")

#Balíček který umí otevřít xlsx i bez Javy hhh

install.packages("openxlsx")

# Library loading

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(flowCore)
library(CATALYST)
library(cyCombine)
library(here)
library(readxl)
library(ggplot2)
library(dplyr)
library(tidyr)
library(ggpubr)
library(rstatix)
library(openxlsx)
```

## Transformace datasetu 

1. Markery - fluorochromy, které byly použity při zpracování vzorků. Dále by měly být vidět detekční kanály a druhy markerů (type - klasifikační marker, state - funkční marker)

```{r}
panel_annotation <- read.xlsx(here('data','metadata.xlsx'), sheet = 'panel_annotation')
panel_annotation
```

2. Import jednotlivých souborů z první části (gatingu).

```{r}
dataset <- read.flowSet(path = here("outputs", "preprocessed"),
                        pattern = ".fcs$",
                        transformation = F,
                        truncate_max_range = F)
```

3. Logical transformace - kombinace logaritmického a lineárního škálování (vysoké x nízké hodnoty signálů). Navržena kvůli záporným hondnotám, které klasická logaritmická transformace nedokáže zpracovat.Výhodou je dobrá vizualizace, schopnost zahrnutí dorbných rozdílů, které by normálně byly potlačeny transformací.

```{r}

for (i in names(dataset@frames)){
  data <- dataset@frames[[i]]
  translist <- estimateLogicle(data, channels = panel_annotation$Fluorochrome)
  data_transformed <- flowCore::transform(data, translist)
  old_filename <- strsplit(i, split = "_")
  old_filename <- old_filename[[1]]
  new_filename <- old_filename[1]
  complete_filename <- paste0(new_filename,"_transformed.fcs")
  print(complete_filename)
  setwd(here('outputs','transformed'))
  write.FCS(data_transformed, file = complete_filename)
}
```
# Loading into CATALYST

4. Soubory byly transformovány - následně je třeba je načíst v jednom setu. Bohužel transformace nebyla u jednoho souboru provedena - po opakovém gatingu se nakonec podařilo.

```{r}
dataset <- read.flowSet(path = here('outputs','transformed'),
                        pattern = ".fcs$", 
                        transformation = FALSE,
                        truncate_max_range = FALSE)
                        #which.lines = 35000
```

```{r}
panel_annotation
```

5. Změna kategorie -> na faktory a poté načíst anotaci jednotlivých vzorků (jedná se o kategorickou proměnnou).

```{r}
sample_annotation <- read.xlsx(here("data", "metadata.xlsx"), sheet = "sample_annotation")

str(sample_annotation)

sample_annotation$Stained_or_control <- as.factor(sample_annotation$Stained_or_control)
sample_annotation$Docetaxel <- as.factor(sample_annotation$Docetaxel)

sample_annotation

```

6. Pořadí souborů by se mělo shodovat s tabulkou - tudíž bude nutné soubory přeuspořádat. Hodí se i případná kontrola, zda vše odpovídá a pořádí není rozhozené (musí být hodnota 0).

```{r}
fcs_files <-names(dataset@frames)

fcs_files
```

```{r}
sample_annotation <- sample_annotation[match(fcs_files, sample_annotation$Filename),]

sample_annotation
```

```{r}
sum((names(dataset@frames) == sample_annotation$Filename) == FALSE)
```
7. Sestavení SingleCellExperiment. Jedná se o speciální balíček, který slouží k analýze dat jednotlivých buněk. Analýza je multiparametrická - máme vícero různých markerů. Budou se zde postupně vkládat naše data.

```{r}
PC <- prepData(dataset, panel_annotation, sample_annotation,
               panel_cols = list(channel = "Fluorochrome", antigen = "Marker", marker_class = 'Marker_class'),
               md_cols = list(file = "Filename", id = "Samples",
                              factors = c("Stained_or_control", "Docetaxel")),
               FACS = TRUE)
```

8. Vygenerujeme graf, který nám říká, kolik buněk mají jednotlivé vzorky. Izotypové kontroly nebývají specificky barvené a i z jiných důvodů by měly obsahovat méně buněk (kratší čas analýzy, množství, které se jich pro analýzu připravuje).

```{r}
plotCounts(PC, group_by = 'sample_id')
# počty buniek na jednotlivé vzorky - kontroly majú minimálny počet lebo neboli farbené (sample 1,4,6,7)
```

# Dimensional reduction

## t-SNE

9.t-SNE (t-distributed Stochastic Neighbor Embedding) je metoda dimenzionální redukce (nelinearita), která se rpoužívá k vizualizaci vysoce dimenzionálních dat. Jde o redukce dimenzí tak, aby blízké buňky zůstaly blízko a vzdálené buňky zůstaly oddělené.

```{r}
PC <- runDR(PC, 
            dr = "TSNE", 
            cells = 20000, 
            features = NULL,
            assay = "exprs",
            seed = 1,
            verbose = TRUE)
```

## UMAP

10. Metoda, která je obdobná t-SNE, ncméně by měla být ještě o něco přesnější a rychlejší. Jedná se o převod do 2D nebo 3D struktury takovým způsobem, aby se zachovaly i struktury, kde jsou buňky mezi sebou více vzdálené.

```{r}
PC <- runDR(PC, 
           dr = "UMAP", 
           cells = 20000,
           features = NULL,
           assay = "exprs",
           verbose = TRUE)
```

# Clustering

11. FlowSom clustery. SOM - (Self-Organizing Map) -> Algoritmus rozloží buňky na základě jejich podobnosti do mřížky. Rozměry mřížky si můžeme sami definovat - nejčastěji podle velikosti datasetu -> zde by měla být odpovídající mřížka 10 x 10 anebo 15 x 15.

```{r}
PC <- cluster(PC, 
              features = NULL, 
              xdim = 15, 
              ydim = 15, 
              maxK = 50, 
              verbose = TRUE, 
              seed = 1)
```

# Data visualization

12. Zobrazení/vizualizace clusterů (t-SNE i UMAP). Můžeme zaměnit i počet clusterů - meta15 nebo meta20 - výsledky se v takovém případě budou lehce odlišovat. Menší počet nám zjednosušší interpretaci, vyšší počet nám dá větší přehled a více detailů

# Každý bod je jedna buňka.
# Buňky, které mají podobnou expresi markerů, se v tSNE mapě seskupí blízko sebe – tvoří shluky.

```{r plotDR, warning = FALSE}
plotDR(PC, dr = "TSNE", color_by = c("meta10"))
```

```{r plotDR, warning = FALSE}
plotDR(PC, dr = "UMAP", color_by = c("meta10"))
```

# Data exploration and quality check

13. Vizualizace dat podle markeru, který zabarví konkrétní buňky - níže v kódu vybrány pouze některé pro kontrolu, zda vše funguje. V metadatech jsou všechny markery.

```{r, warning = FALSE}
plotDR(PC, dr = "TSNE", color_by = c("CD9", "CD44", "CD63", "CD71", "CD81", "CD95", "CD166", "CD201"), ncol = 3)
```
14. Facetování t-SNE

#Facetování = rozdělení grafu do panelů podle určité proměnné (zde se jedná o Docetaxel)

#Docetaxel = polosyntetická látka vzniklá úpravou molekuly paklitaxelu. V medicíně je využíván jako cytostatikum (používání v protinádorové léčbě).

#Proměnná Docetaxel -> t-SNE mapa se rozdělí podle toho, zda buňky pochází z citlivých nebo rezistentních vzorků.

# Batch - docházé ke vzniku drobných ostrovků - bude nutná korekce dat. 

```{r, warning = FALSE}
plotDR(PC, dr = "TSNE", color_by = c("meta10"), facet_by = "Docetaxel")
```

# Data integration

## Data loading and conversion into dataframe

15. Tvorba velkého data.frame, který nám pomůže data integrovat (z různých zdrojů do jednoho).
 
```{r}
uncorrected <- convert_flowset(flowset = dataset,
                               metadata = sample_annotation,
                               filename_col = "Filename",
                               sample_ids = "Samples", 
                               batch_ids = "Docetaxel",
                               condition = "Stained_or_control",
                               anchor =  "Stained_or_control",
                               panel = panel_annotation, 
                               panel_channel = "Fluorochrome",
                               panel_antigen = "Marker",
                               down_sample = FALSE,
                               seed = 1)

```

## Batch correction

16. Pomocí CyCombine (umí integrovat, normalizovat, transformovat, ...) se zkusí opravit Batch.

```{r}
corrected <- batch_correct(df = uncorrected,
                           covar = "condition",
                           markers = colnames(uncorrected[2:16]),
                           norm_method = "scale", 
                           rlen = 20, 
                           seed = 1,
                           anchor = "anchor")
```

17. Převod tabulky zpět do data.frame.

```{r}
corrected <- data.frame(corrected)
```

## Evaluation the efficacy of the batch correction

18. Výpočet procentuální redukce Batch efektu.

```{r}
emd <- evaluate_emd(uncorrected = uncorrected,
                    corrected = corrected,
                    cell_col = "condition",
                    batch_col = "batch",
                    markers = colnames(uncorrected[2:16]))

#EMD = 0.23 --> snížení o 23%
```
19. Výpočet MAD = jak moc korekce batch efektu ovlivnila biologickou variabilitu buněk.

#Vyšlo to nula -> ztráta variability, vysoká homogenita dat, proč?

```{r}
mad <- evaluate_mad(uncorrected = uncorrected,
                    corrected = corrected,
                    cell_col = "condition",
                    batch_col = "batch",
                    markers = colnames(uncorrected[2:16]))

# MAD = 0.00
```

## Preparation for FCS file export

20. Vymazat všecky sloupce, které nepasují - nesouvisisí s markery

```{r}
corrected$id <- NULL
corrected$label <- NULL
corrected$condition <- NULL
corrected$anchor <- NULL
corrected$batch <- NULL

corrected
```

21. Přehodit ID vzorků na faktor a zobrazit (převod na kategoriální proměnnou).

```{r}
corrected$sample <- as.factor(corrected$sample)
levels(corrected$sample)
```
## For loop for export

22. Export corrected FCS dat do složky integrated (z opraveného = corrected = matrixu).


```{r}
for (i in levels(corrected$sample)){
  data_filtered <- corrected[corrected$sample == i, ]
  data_filtered$sample <- NULL
  data_filtered <- flowCore::flowFrame(as.matrix(data_filtered))
  setwd(here('outputs','integrated'))
  complete_filename <- paste0(i,'_integrated.fcs')
  print(complete_filename)
  write.FCS(data_filtered, file = complete_filename)
}
```

# Loading into CATALYST - integrated data

23. Načtení zintegrovaných dat zpět jako FlowSet pro další úpravy. 
 
```{r}
dataset <- read.flowSet(path = here('outputs','integrated'),
                        pattern = ".fcs$", 
                        transformation = FALSE,
                        truncate_max_range = FALSE)
                        #which.lines = 35000
```

24. Načtení informací o panelu (from panel_integrated_data sheet in the metadata.xlsx file). 

```{r}
panel_integrated <- read.xlsx(here('data','metadata.xlsx'), sheet = 'panel_integrated_data')
panel_integrated
```

25. Kontrola pořadí a názvu souborů (v fcs_files i sample_annotation$Filename_integrated). 

```{r}
sample_annotation$Filename_integrated
```
26. Pořadí souborů by se mělo shodovat s tabulkou - tudíž bude nutné soubory přeuspořádat. Hodí se i případná kontrola, zda vše odpovídá a pořádí není rozhozené (musí být hodnota 0). Stejné jako krok 6.

```{r}
fcs_files <- names(dataset@frames)
fcs_files
```

```{r}
sample_annotation_int <- sample_annotation[match(fcs_files, sample_annotation$Filename_integrated),]
 
sample_annotation_int
```

```{r}
sum((names(dataset@frames) == sample_annotation_int$Filename_integrated) == FALSE)
```
27. Opakovat SingleCellExperiment, akorát s integrovanými soubory.

```{r}

PC_integrated <- prepData(dataset, panel_integrated, sample_annotation_int,
                          panel_cols = list(channel = "Fluorochrome", 
                                            antigen = "Marker", 
                                            marker_class = 'Marker_class'),
                          md_cols = list(file = "Filename_integrated", 
                                         id = "Samples",
                          factors = c("Stained_or_control", "Docetaxel")),
                          FACS = TRUE)
```

28. Nový graf s integrovanými daty, popisující množství buněk ve vzorcích.

```{r}
plotCounts(PC_integrated, group_by = 'sample_id')
```

# Dimensional reduction

## t-SNE

29. Opět provedena t-SNE redukce.
 
```{r}
PC_integrated <- runDR(PC_integrated, 
                       dr = "TSNE", 
                       cells = 20000, 
                       features = NULL,
                       assay = "exprs",
                       seed = 1,
                       verbose = TRUE)
```

## UMAP

30. Provedení UMAP (popsáno na začátku) na integrovaných datech.

```{r}
PC_integrated <- runDR(PC_integrated, 
                       dr = "UMAP", 
                       cells = 20000,
                       features = NULL,
                       assay = "exprs",
                       verbose = TRUE)
```

# Clustering

31. Proveden FlowSom (stejně jako na začátku) na integrovaných datech. Mřížka zvolena nakonec 15 x 15.

```{r}
PC_integrated <- cluster(PC_integrated, 
                         features = NULL, 
                         xdim = 15, 
                         ydim = 15, 
                         maxK = 50, 
                         verbose = TRUE, 
                         seed = 1)
```

# Data visualization and quality check

32. Grafické znázornění pomocí t-SNE a UMAP.

```{r}
plotDR(PC_integrated, dr = "TSNE", color_by = c("meta10"))
```

```{r}
plotDR(PC_integrated, dr = "UMAP", color_by = c("meta10"))
```

33. Facety pro kontrolu Batch efektu.

# Bylo to potřeba?

```{r, warning = FALSE}
plotDR(PC, dr = "TSNE", color_by = c("meta10"), facet_by = "Docetaxel")
```

# Data exploration

34. Vizualizace dat podle markeru, který zabarví konkrétní buňky - níže v kódu vybrány pouze některé pro kontrolu, zda vše funguje. V metadatech jsou všechny markery.

```{r, warning = FALSE}
plotDR(PC, dr = "TSNE", color_by = c("CD9", "CD44", "CD63", "CD71", "CD81", "CD95", "CD166", "CD201"), ncol = 3)
```

35. You can also include heatmap showing the marker expression in columns and clusters in rows, for better annotation of the dataset.

# Doplnit popis

```{r}
plotExprHeatmap(PC_integrated, 
                features = NULL,
                by = "cluster_id", 
                k = "meta25",
                scale = "never", 
                q = 0.01, 
                perc = TRUE, 
                col_dend = FALSE,
                col_clust = TRUE,
                row_dend = FALSE,
                row_clust = FALSE)
```

# Annotation

36. Use the expression profile mentioned below to annotate the clusters in your dataset (fill into the cluster_annotation sheet in metadata.xlsx file). Then, load your cluster annotation here and display it in the report.

- NK cells - CD45+ CD161+ 
- healthy B cells - CD45+ CD19+ CD5- CD44-
- leukemic B cells - CD45+ CD19+ CD5+ CD44+ 
- naive CD4+ T cells - CD45+ CD4+ CD62L+ CD44-
- effector-memory CD4+ T cells - CD45+ CD4+ CD62L- CD44+
- central memory CD4+ T cells - CD45+ CD4+ CD62L+ CD44+
- Treg - CD45+ CD4+ CD25+ GITR+
- naive CD8+ T cells - CD45+ CD8a+ CD62L+ CD44-
- effector-memory CD8+ T cells - CD45+ CD8a+ CD62L- CD44+
- central memory CD8+ T cells - CD45+ CD8a+ CD62L+ CD44+ 
- exhausted CD8+ T cells - CD45+ CD8a+ PD-1+
- senescent CD8+ T cells - CD45+ CD8a+ KLRG-1+
- contamination/unknown - CD45-

```{r}
cluster_annotation <- 
```

41. Use the table to annotate the clusters in your dataset - creating a new object called PB_annotated. 

```{r}
PB_annotated <- mergeClusters(PB_integrated, 
                              k = "meta25",
                              id = "annotation",
                              table = cluster_annotation)
```

42. Display the annotated clusters. 

```{r}

```

# Exclusion of unwanted populations

43. Exclude the contamination from your dataset using the filterSCE function. 

```{r}
PB_annotated <- filterSCE(PB_annotated, 
                          k = 'annotation',
                          cluster_id != "unknown")
```

44. Visualize the annotated clusters again. 

```{r}

```

# Differential analysis

45. Plot the abundances of annotated populations for each of the samples, and group the samples together according to the CLL stage. 

```{r}

```

# Table export and conversion to percentages

46. Export the absolute counts of cells in annotated populations from the dataset. 

```{r, warning=FALSE}
PB_annotated$annotation <- cluster_ids(PB_annotated, "annotation")

all_populations <- as.data.frame(table(PB_annotated$sample_id, group.by = PB_annotated$annotation))
all_populations <- all_populations %>% pivot_wider(names_from = group.by, values_from = Freq)
all_populations
```

47. Use these counts to calculate the percentages of TOTAL for each population and each mouse (using the code below). 

```{r}
cols <- 2:ncol(all_populations)

perc_all_populations <- all_populations[cols]/rowSums(all_populations[cols]) * 100
perc_all_populations$TOTAL <- rowSums(perc_all_populations)
```

```{r}
rownames(perc_all_populations) <- all_populations$Var1

sample_annotation <- sample_annotation[match(rownames(perc_all_populations), sample_annotation$Mouse_ID),]
perc_all_populations$Stage <- as.factor(sample_annotation$Stage)
perc_all_populations
```

48. Export the table with percentages as a separate csv file. 

```{r}

```

# EXAMPLE Visualization and testing of difference in the abundance of leukemic B cells in distinct CLL stages

49. Test for the distribution of leukemic B cell abundances in the dataset. Choose right statistical test + post-hoc testing accordingly (using the code below).

```{r}
shapiro.test(perc_all_populations$`leukemic B cells`)
```

```{r}
kruskal.test(`leukemic B cells` ~ Stage, perc_all_populations)
```

```{r}
pairwise.wilcox.test(
  perc_all_populations$`leukemic B cells`,
  perc_all_populations$Stage,
  p.adjust.method = 'BH')
```

50. Visualize the abundance using the code for boxplot written below. You can also automatically include the p-values from post-hoc testing you wish to display directly in the plot via stat_pvalue_manual. 

```{r}
perc_all_long <- perc_all_populations %>% 
  pivot_longer(
    cols = 1:(ncol(perc_all_populations)-2), 
    names_to = "Celltype",
    values_to = "Percentage")
```

```{r, echo=FALSE}
CLL_plot <- perc_all_long %>% filter(Celltype == "leukemic B cells")
CLL_plot$Celltype <- as.factor(CLL_plot$Celltype)

stat.test <- perc_all_populations %>% pairwise_wilcox_test(`leukemic B cells` ~ Stage, p.adjust.method = 'BH')

p <- ggplot(CLL_plot, aes(x = factor(Stage), y = Percentage)) +
            geom_boxplot(outlier.size = 0, fill = c('#D9D9D9','#D37A7A','red','darkred')) + 
            labs(x = "Condition", y = "% of CD45+ cells") +
            ylim(0,105) +
            geom_jitter(position=position_dodge(0.75)) +
            stat_pvalue_manual(stat.test, y.position = c(88,93,98,120,120,120),label = 'p.adj',tip.length = 0.01) + 
            theme_bw()
p
```

# Dataset export

51. Export the annotated SingleCellExperiment object as an rds file into the ~/outputs folder. 

```{r}

```


# Analysis of the T cell subsets (optional homework)

- Subset the dataset only to T cells. 
- Perform dimensional reduction again and verify if in further detail, the T cell subsets have been annotated correctly. If not, then re-cluster and re-annotate the T cell populations in the T cell dataset.
- Visualize the T cell subset abundances. 
- Test for statistical significance in abundances of all T cell subsets between mice of different CLL stages. 
- Visualize the abundances of T cell subsets that show significant differences in their abundance between CLL stages. 

# Session info

52. Do not forget to add the session info. 

```{r}

```
